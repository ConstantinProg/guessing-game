# Общая архитектура

За основу была взята упрощённая чистая архитектура с некоторыми элементами DDD. В процессе реализации UI был использован шаблон проектирования - фасад. Также доменная модель использует паттерн ValueObject.

# Принцип единственной обязанности (SRP — The Single Responsibility Principle)

У класса/модуля должна быть лишь одна причина для изменения. Данный принцип
говорит о борьбе с изменениями, но на самом деле суть его сводится к борьбе со
сложностью. Любой сложный класс должен быть разбит
на несколько простых составляющих, отвечающих за определенный аспект поведения. Это упрощает как понимание, так и развитие класса в будущем. Простой
класс с небольшим числом зависимостей легко изменить независимо от того, сколько причин для изменения существует. Разработчик очень редко знает, как требования изменятся в будущем, что делает простое решение лучшим способом обеспечения гибкости.

## Что сделано?

Все классы небольшого размера и выполняют одну задачу.

# Принцип «открыт/закрыт» (OCP — The Open-Closed Principle)

Программные сущности должны быть открытыми для расширения, но закрытыми для модификации. Любой готовый модуль должен быть стабильным (закрытым) с точки зрения своего интерфейса, но открытым с точки
зрения реализации. Закрытость модулей означает стабильность интерфейса и возможность использования модулей его клиентами. Открытость модулей означает
возможность его изменения путем изменения реализации или же путем переопределения поведения за счет создания наследников. Сокрытие информации и полиморфизм позволяют ограничить количество изменений, которые понадобится
внести в систему при очередном изменении требований, что сделает этот процесс
более простым и управляемым.

## Что сделано?

Все предполагаемые точки расширения приложения снабжены интерфейсами, с помощью которых внешний код передаёт реализации. Все классы максимально инкапсулированы.

# Принцип замещения Лисков (LSP — The Liskov Substitution Principle)

Должна существовать возможность вместо базового типа подставить любой его подтип.
Поскольку наследование является одним из ключевых механизмов объектно-ориентированного проектирования, очень важно использовать его корректным образом.
Данный принцип дает четкие рекомендации о том, в каких пределах может изменяться поведение методов, переопределенных в производных классах, чтобы между
классами сохранялось отношение «ЯВЛЯЕТСЯ».

## Что сделано?

Классы GuessingGame.Domain.Numbers не противоречат принципу  LSP. Больше наследование нигде не используется.

# Принцип разделения интерфейсов (ISP — The Interface Segregation Principle)

Клиенты не должны вынужденно зависеть от методов, которыми не пользуются.
Интерфейс класса определяется некоторым контрактом, которому он должен следовать ради своих клиентов. Иногда возникают ситуации, когда у разных клиентов
появляются различные сценарии использования класса, в результате чего его интерфейс становится несогласованным и неудобным в использовании. Данный
принцип говорит о том, что клиенты хотят иметь цельный и согласованный интерфейс сервисов независимо от того, пользуется ли этими сервисами еще кто-то,
кроме них, или нет.

## Что сделано?

Все интерфейсы не противоречат принципам ASP, так как у них нет нескольких клиентов, которые бы использовали их. В остальном я руководствовался здравым смыслом.

# Принцип инверсии зависимостей (DIP — The Dependency Inversion Principle)

Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те
и другие должны зависеть от абстракций. Слишком большое число зависимостей
класса говорит о проблемах в его дизайне. Возможно, класс делает слишком многое
или же он неудачно спроектирован, что приводит к необходимости вызова по одному методу у большого числа зависимостей. Любая объектная система представляет собой граф взаимодействующих объектов. При этом некоторые зависимости
являются деталями реализации и контролируются классами самостоятельно, а некоторые должны передаваться извне при конструировании объектов. Данный
принцип говорит о необходимости выделения и передачи ключевых зависимостей
через аргументы конструктора, что позволяет перенести проблемы создания и выбора конкретных зависимостей на вызывающий код.

## Что сделано?

Все зависимости передаются через аргументы конструктора. Все модули зависят от абстракций.